'use client';

import React, { useCallback, useMemo, useState, useEffect } from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import { usePage, router } from '@inertiajs/react';
import bs58 from 'bs58';

type PageProps = {
  auth?: { user?: { id: number; name: string; wallet: string } | null };
};

const short = (a?: string) => (a ? `${a.slice(0, 4)}‚Ä¶${a.slice(-4)}` : '');

export default function WalletAuth() {
  const { 
    connected, 
    publicKey, 
    signMessage, 
    disconnect, 
    select, 
    connect, 
    wallet,
    wallets,
    connecting 
  } = useWallet();
  
  const { props } = usePage<PageProps>();
  const isAuthed = !!props.auth?.user;

  const [busy, setBusy] = useState(false);
  const [err, setErr] = useState<string | null>(null);
  const [pendingAction, setPendingAction] = useState<'select' | 'connect' | null>(null);

  // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è
  useEffect(() => {
    console.log('=== Wallet State ===', {
      connected,
      connecting,
      wallet: wallet?.adapter?.name,
      wallets: wallets.map(w => w.adapter.name),
      publicKey: publicKey?.toBase58(),
      busy,
      pendingAction,
      isAuthed
    });
  }, [connected, connecting, wallet, wallets, publicKey, busy, pendingAction, isAuthed]);

  // –ù–∞—Ö–æ–¥–∏–º Phantom wallet
  const phantomWallet = useMemo(
    () => wallets.find((w) => 
      w.adapter.name === 'Phantom' || 
      w.adapter.name.includes('Phantom')
    ),
    [wallets]
  );

  const login = useCallback(async () => {
    console.log('üîê Starting login...');
    if (!connected || !publicKey || !signMessage) {
      console.error('‚ùå Login failed - missing requirements:', { connected, publicKey: !!publicKey, signMessage: !!signMessage });
      throw new Error('Wallet not connected or signMessage unavailable');
    }

    try {
      // 1) nonce + message
      const nonceResp = await fetch('/wallet/nonce', {
        credentials: 'same-origin',
        headers: { 'X-Requested-With': 'XMLHttpRequest' },
      });
      const { nonce, message } = await nonceResp.json();
      console.log('üìù Got nonce:', nonce);

      // 2) –ø–æ–¥–ø–∏—Å—å
      const sig = await signMessage(new TextEncoder().encode(message));
      const signatureB58 = bs58.encode(sig);
      console.log('‚úçÔ∏è Signed message');

      // 3) verify
      const token = (document.querySelector('meta[name="csrf-token"]') as HTMLMetaElement)?.content;
      const resp = await fetch('/wallet/verify', {
        method: 'POST',
        credentials: 'same-origin',
        headers: {
          'Content-Type': 'application/json',
          'X-Requested-With': 'XMLHttpRequest',
          'X-CSRF-TOKEN': token ?? '',
        },
        body: JSON.stringify({
          address: publicKey.toBase58(),
          signature: signatureB58,
          nonce,
        }),
      });

      if (!resp.ok) throw new Error((await resp.text().catch(() => '')) || 'Login failed');
      
      console.log('‚úÖ Login successful');
      await router.reload({ only: ['auth'] });
    } catch (e: any) {
      console.error('‚ùå Login error:', e);
      throw e;
    }
  }, [connected, publicKey, signMessage]);

  // –≠—Ñ—Ñ–µ–∫—Ç –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤—ã–±–æ—Ä–∞ wallet –∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
  useEffect(() => {
    const handlePendingAction = async () => {
      console.log('üîÑ useEffect pendingAction:', pendingAction, 'wallet:', wallet?.adapter?.name);
      
      // –ï—Å–ª–∏ –∂–¥–µ–º –≤—ã–±–æ—Ä wallet –∏ –æ–Ω –ø–æ—è–≤–∏–ª—Å—è
      if (pendingAction === 'select' && wallet && wallet.adapter && wallet.adapter.name.includes('Phantom')) {
        console.log('üëª Phantom selected, attempting connection...');
        
        // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –ø–æ—Å–ª–µ select –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
        await new Promise(resolve => setTimeout(resolve, 100));
        
        setPendingAction('connect');
        
        try {
          console.log('üîå Calling connect() from hook...');
          await connect();
          console.log('‚úÖ Connected successfully, connected state:', connected);
          setPendingAction(null);
        } catch (e: any) {
          console.error('‚ùå Connection error:', e);
          console.error('Error name:', e?.name);
          console.error('Error message:', e?.message);
          
          // –ï—Å–ª–∏ –æ—à–∏–±–∫–∞ WalletNotSelectedError, –ø—Ä–æ–±—É–µ–º –µ—â–µ —Ä–∞–∑
          if (e?.name === 'WalletNotSelectedError') {
            console.log('üîÑ Retrying with select + connect...');
            try {
              // –ü–æ–≤—Ç–æ—Ä—è–µ–º select
              select(wallet.adapter.name);
              await new Promise(resolve => setTimeout(resolve, 200));
              await connect();
              console.log('‚úÖ Retry successful');
              setPendingAction(null);
            } catch (retryError: any) {
              console.error('‚ùå Retry failed:', retryError);
              setErr(retryError?.message || String(retryError));
              setPendingAction(null);
              setBusy(false);
            }
          } else if (!e?.message?.includes('User rejected')) {
            setErr(e?.message || String(e));
            setPendingAction(null);
            setBusy(false);
          } else {
            setPendingAction(null);
            setBusy(false);
          }
        }
      }
    };

    handlePendingAction();
  }, [wallet, pendingAction, connect, connected, select]);

  // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ª–æ–≥–∏–Ω –ø–æ—Å–ª–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
  useEffect(() => {
    const autoLogin = async () => {
      console.log('üîÑ Auto-login check:', {
        connected,
        hasPublicKey: !!publicKey,
        hasSignMessage: !!signMessage,
        isAuthed,
        busy,
        connecting
      });

      if (connected && publicKey && signMessage && !isAuthed && busy && !connecting) {
        console.log('üöÄ Starting auto-login...');
        try {
          await login();
        } catch (e: any) {
          console.error('‚ùå Auto-login error:', e);
          if (!e?.message?.includes('User rejected')) {
            setErr(e?.message || String(e));
          }
        } finally {
          setBusy(false);
        }
      }
    };

    autoLogin();
  }, [connected, publicKey, signMessage, isAuthed, busy, connecting, login]);

  const handleConnect = useCallback(async () => {
    console.log('üñ±Ô∏è Connect button clicked');
    setErr(null);

    // –ï—Å–ª–∏ —É–∂–µ –ø–æ–¥–∫–ª—é—á–µ–Ω –∏ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω
    if (connected && isAuthed) {
      console.log('‚úÖ Already connected and authenticated');
      return;
    }

    setBusy(true);

    try {
      // –ï—Å–ª–∏ —É–∂–µ –ø–æ–¥–∫–ª—é—á–µ–Ω, –Ω–æ –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω - —Å—Ä–∞–∑—É –ª–æ–≥–∏–Ω–∏–º—Å—è
      if (connected && !isAuthed && publicKey && signMessage) {
        console.log('üîê Already connected, logging in...');
        await login();
        setBusy(false);
        return;
      }

      // –ï—Å–ª–∏ –Ω–µ –ø–æ–¥–∫–ª—é—á–µ–Ω
      if (!connected) {
        console.log('üîç Not connected, checking for Phantom...');
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ Phantom
        if (!phantomWallet) {
          console.error('‚ùå Phantom wallet not found');
          setBusy(false);
          setErr('Phantom wallet not found. Please install Phantom extension.');
          return;
        }

        console.log('‚úÖ Phantom found:', phantomWallet.adapter.name);

        // –í–ê–ñ–ù–û: –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ wallet –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω –∏ –≤—ã–±—Ä–∞–Ω
        // –ü–æ—Å–ª–µ logout wallet —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è undefined, –¥–∞–∂–µ –µ—Å–ª–∏ Phantom –≤ —Å–ø–∏—Å–∫–µ
        if (wallet && wallet.adapter && wallet.adapter.name.includes('Phantom')) {
          console.log('üì± Wallet already selected, connecting with hook connect()...');
          try {
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º connect() –∏–∑ —Ö—É–∫–∞, –∞ –Ω–µ wallet.adapter.connect()
            await connect();
            console.log('‚úÖ Direct connection successful');
          } catch (e: any) {
            console.error('‚ùå Direct connection failed:', e);
            if (!e?.message?.includes('User rejected')) {
              setErr(e?.message || String(e));
            }
            setBusy(false);
          }
        } else {
          // Wallet –Ω–µ –≤—ã–±—Ä–∞–Ω –∏–ª–∏ undefined - –Ω—É–∂–Ω–æ –≤—ã–±—Ä–∞—Ç—å
          console.log('üéØ Wallet is undefined or not selected, selecting Phantom...');
          console.log('Current wallet state:', wallet);
          select(phantomWallet.adapter.name);
          setPendingAction('select');
          console.log('‚è≥ Waiting for wallet selection to complete...');
          // –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–æ–π–¥–µ—Ç —á–µ—Ä–µ–∑ useEffect
        }
      }
    } catch (e: any) {
      console.error('‚ùå HandleConnect error:', e);
      if (!e?.message?.includes('User rejected')) {
        setErr(e?.message || String(e));
      }
      setBusy(false);
    }
  }, [connected, isAuthed, publicKey, signMessage, wallet, phantomWallet, select, login]);

  const logout = useCallback(async () => {
    console.log('üö™ Logging out...');
    setErr(null);
    setBusy(true);
    setPendingAction(null);
    
    try {
      const token = (document.querySelector('meta[name="csrf-token"]') as HTMLMetaElement)?.content;
      await fetch('/logout', {
        method: 'POST',
        headers: { 
          'X-CSRF-TOKEN': token ?? '', 
          'X-Requested-With': 'XMLHttpRequest' 
        },
        credentials: 'same-origin',
      });
      
      // –û—Ç–∫–ª—é—á–∞–µ–º –∫–æ—à–µ–ª–µ–∫
      try { 
        await disconnect(); 
      } catch {}
      
      console.log('üîÑ Reloading page...');
      // –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü—É
      window.location.href = window.location.href;
    } catch (e: any) {
      console.error('‚ùå Logout error:', e);
      setErr(e?.message || String(e));
      setBusy(false);
    }
  }, [disconnect]);

  const buttonLabel = useMemo(() => {
    if (connecting || busy || pendingAction) return 'Connecting‚Ä¶';
    if (!connected) return 'Connect Phantom';
    if (connected && !isAuthed) return 'Sign in';
    return 'Connected';
  }, [connected, isAuthed, busy, connecting, pendingAction]);

  const isPhantomAvailable = useMemo(() => !!phantomWallet, [phantomWallet]);

  return (
    <div className="flex flex-col gap-3">
      {!isAuthed ? (
        <>
          <button
            onClick={handleConnect}
            disabled={busy || connecting || pendingAction !== null || (connected && isAuthed) || !isPhantomAvailable}
            className="px-4 py-2 rounded bg-indigo-600 text-white disabled:opacity-60 disabled:cursor-not-allowed hover:bg-indigo-700 transition-colors"
          >
            {!isPhantomAvailable ? 'Phantom not installed' : buttonLabel}
          </button>
          
          {!isPhantomAvailable && (
            <p className="text-xs text-yellow-500">
              Please install{' '}
              <a 
                href="https://phantom.app/" 
                target="_blank" 
                rel="noopener noreferrer"
                className="underline hover:text-yellow-400"
              >
                Phantom wallet extension
              </a>
            </p>
          )}
        </>
      ) : (
        <div className="flex justify-between items-center gap-3">
          <p className="text-sm text-gray-400">
            {publicKey ? ` ${short(publicKey.toBase58())}` : ''}
          </p>
          <button
            onClick={logout}
            disabled={busy}
            className="px-3 py-1.5 rounded border border-gray-600 text-gray-200 hover:bg-gray-800 disabled:opacity-60 disabled:cursor-not-allowed transition-colors"
          >
            {busy ? 'Logging out‚Ä¶' : 'Logout'}
          </button>
        </div>
      )}

      {err && <div className="text-xs text-red-500">{err}</div>}
      
    </div>
  );
}